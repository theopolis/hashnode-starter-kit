import { addPublicationJsonLd } from '@starter-kit/utils/seo/addPublicationJsonLd';
import { getAutogeneratedPublicationOG } from '@starter-kit/utils/social/og';
import request from 'graphql-request';
import { GetStaticProps } from 'next';
import Head from 'next/head';
import Link from 'next/link';
import { useMemo, useState } from 'react';
import { Waypoint } from 'react-waypoint';
import { Container } from '../components/container';
import { AppProvider } from '../components/contexts/appContext';
import { Footer } from '../components/footer';
import { Layout } from '../components/layout';
import { MinimalPosts } from '../components/minimal-posts';
import { PersonalHeader } from '../components/personal-theme-header';
import {
	MorePostsByPublicationDocument,
	MorePostsByPublicationQuery,
	MorePostsByPublicationQueryVariables,
	PageInfoFragment,
	PostFragment,
	PostsByPublicationDocument,
	PostsByPublicationQuery,
	PostsByPublicationQueryVariables,
	PublicationFragment,
	SeriesListDocument,
	SeriesListQuery,
	SeriesListQueryVariables,
} from '../generated/graphql';

const GQL_ENDPOINT = process.env.NEXT_PUBLIC_HASHNODE_GQL_ENDPOINT;

type SeriesInfo = {
	id: string;
	name: string;
	slug: string;
	description: string | null;
	postCount: number;
};

type Props = {
	publication: PublicationFragment;
	initialPosts: PostFragment[];
	initialPageInfo: PageInfoFragment;
	seriesList: SeriesInfo[];
};

export default function Index({ publication, initialPosts, initialPageInfo, seriesList }: Props) {
	const [posts, setPosts] = useState<PostFragment[]>(initialPosts);
	const [pageInfo, setPageInfo] = useState<Props['initialPageInfo']>(initialPageInfo);
	const [loadedMore, setLoadedMore] = useState(false);
	
	const postsBySeries = useMemo(() => {
		const grouped = new Map<string, PostFragment[]>();
		const uncategorized: PostFragment[] = [];
		
		posts.forEach((post) => {
			if (post.series) {
				const existing = grouped.get(post.series.slug) || [];
				grouped.set(post.series.slug, [...existing, post]);
			} else {
				uncategorized.push(post);
			}
		});
		
		return { grouped, uncategorized };
	}, [posts]);
	
	const tagCloud = useMemo(() => {
		const tagsMap = new Map<string, { slug: string; name: string; count: number }>();
		posts.forEach((post) => {
			(post.tags ?? []).forEach((tag) => {
				const existing = tagsMap.get(tag.slug);
				if (existing) {
					existing.count += 1;
				} else {
					tagsMap.set(tag.slug, { slug: tag.slug, name: tag.name, count: 1 });
				}
			});
		});
		return Array.from(tagsMap.values()).sort((a, b) => a.name.localeCompare(b.name));
	}, [posts]);

	const loadMore = async () => {
		const data = await request<MorePostsByPublicationQuery, MorePostsByPublicationQueryVariables>(
			GQL_ENDPOINT,
			MorePostsByPublicationDocument,
			{
				first: 20,
				host: process.env.NEXT_PUBLIC_HASHNODE_PUBLICATION_HOST,
				after: pageInfo.endCursor,
			},
		);
		if (!data.publication) {
			return;
		}
		const newPosts = data.publication.posts.edges.map((edge) => edge.node);
		setPosts([...posts, ...newPosts]);
		setPageInfo(data.publication.posts.pageInfo);
		setLoadedMore(true);
	};
	return (
		<AppProvider publication={publication}>
			<Layout>
				<Head>
					<title>{publication.title}</title>
					<meta
						name="description"
						content={
							publication.descriptionSEO || publication.title || `${publication.author.name}'s Blog`
						}
					/>
					<meta property="twitter:card" content="summary_large_image"/>
					<meta property="twitter:title" content={publication.displayTitle || publication.title || 'Hashnode Blog Starter Kit'} />
					<meta property="twitter:description" content={publication.descriptionSEO || publication.title || `${publication.author.name}'s Blog`} />
					<meta
						property="og:image"
						content={publication.ogMetaData.image || getAutogeneratedPublicationOG(publication)}
					/>
					<meta
						property="twitter:image"
						content={publication.ogMetaData.image || getAutogeneratedPublicationOG(publication)}
					/>
					<script
						type="application/ld+json"
						dangerouslySetInnerHTML={{
							__html: JSON.stringify(addPublicationJsonLd(publication)),
						}}
					/>
				</Head>
				<Container className="mx-auto flex max-w-3xl flex-col items-stretch gap-10 px-5 py-10">
				<PersonalHeader seriesList={seriesList} />
				{seriesList.map((series) => {
					const seriesPosts = postsBySeries.grouped.get(series.slug) || [];
					const displayPosts = seriesPosts.slice(0, 10);
					
					if (displayPosts.length === 0) return null;
					
					return (
						<section key={series.id} id={series.slug} className="flex flex-col gap-6">
							<div className="flex items-center justify-between">
								<div>
									<Link href={`/series/${series.slug}`}>
										<h2 className="text-2xl font-bold text-black hover:text-slate-600 dark:text-white dark:hover:text-slate-300">
											{series.name}
										</h2>
									</Link>
									{series.description && (
										<p className="mt-1 text-sm text-slate-600 dark:text-slate-400">
											{series.description}
										</p>
									)}
								</div>
								{seriesPosts.length > 10 && (
									<Link
										href={`/series/${series.slug}`}
										className="text-sm font-medium text-slate-600 hover:text-black dark:text-slate-400 dark:hover:text-white"
									>
										View all {seriesPosts.length} â†’
									</Link>
								)}
							</div>
							<MinimalPosts context="series" posts={displayPosts} />
						</section>
					);
				})}

				{postsBySeries.uncategorized.length > 0 && (
					<section className="flex flex-col gap-6">
						<h2 className="text-2xl font-bold text-black dark:text-white">Other Articles</h2>
						<MinimalPosts context="home" posts={postsBySeries.uncategorized.slice(0, 10)} />
					</section>
				)}

					{!loadedMore && pageInfo.hasNextPage && pageInfo.endCursor && (
						<button onClick={loadMore}>
							Load more
						</button>
					)}
					{loadedMore && pageInfo.hasNextPage && pageInfo.endCursor && (
						<Waypoint onEnter={loadMore} bottomOffset={'10%'} />
					)}

					{tagCloud.length > 0 && (
						<section className="flex flex-col gap-4 pt-4">
							<h2 className="text-xs font-semibold uppercase tracking-wide text-slate-500 dark:text-slate-400">
								Browse by topic
							</h2>
							<div className="flex flex-wrap gap-2">
								{tagCloud.map((tag) => (
									<Link
										key={tag.slug}
										href={`/tag/${tag.slug}`}
										className="flex items-center gap-1 rounded-full border border-slate-200 px-2.5 py-1 text-xs text-slate-600 hover:bg-slate-50 dark:border-neutral-800 dark:text-neutral-300 dark:hover:bg-neutral-800"
									>
										<span>#{tag.slug}</span>
										<span className="text-[10px] text-slate-400 dark:text-neutral-500">{tag.count}</span>
									</Link>
								))}
							</div>
						</section>
					)}

					<Footer />
				</Container>
			</Layout>
		</AppProvider>
	);
}

export const getStaticProps: GetStaticProps<Props> = async () => {
	const postsData = await request<PostsByPublicationQuery, PostsByPublicationQueryVariables>(
		GQL_ENDPOINT,
		PostsByPublicationDocument,
		{
			first: 20,
			host: process.env.NEXT_PUBLIC_HASHNODE_PUBLICATION_HOST,
		},
	);

	const seriesData = await request<SeriesListQuery, SeriesListQueryVariables>(
		GQL_ENDPOINT,
		SeriesListDocument,
		{
			first: 10,
			host: process.env.NEXT_PUBLIC_HASHNODE_PUBLICATION_HOST,
		},
	);

	const publication = postsData.publication;
	if (!publication) {
		return {
			notFound: true,
		};
	}
	const initialPosts = (publication.posts.edges ?? []).map((edge) => edge.node);
	const seriesList = (seriesData.publication?.seriesList.edges ?? []).map((edge) => ({
		id: edge.node.id,
		name: edge.node.name,
		slug: edge.node.slug,
		description: edge.node.description?.text || null,
		postCount: edge.node.posts.totalDocuments,
	}));

	return {
		props: {
			publication,
			initialPosts,
			initialPageInfo: publication.posts.pageInfo,
			seriesList,
		},
		revalidate: 1,
	};
};
